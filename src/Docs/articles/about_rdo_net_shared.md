Relational Data Objects for .Net (RDO.Net) is a lightweight, yet comprehensive framework to develop enterprise application in .Net platform, targeting .Net developers. It consists of the following libraries and tools:

![image](/images/RdoNetOverview.jpg)

RDO.Net is licensed separately for its runtime and design-time tools:

* [RDO.Net Runtime License](xref:rdo_net_runtime_license)
* [RDO.Tools License](xref:rdo_tools_license)

## Why choose RDO.Net

Enterprise application, typically backed by a relational database, has decades of history. Today's enterprise applications are unnecessarily complex and heavyweight, due to the following technical constraints:

* [Object-Relational Mapping (ORM, O/RM, and O/R mapping tool)](https://en.wikipedia.org/wiki/Object-relational_mapping), as the core of enterprise applications, is still [The Vietnam of Computer Science](http://blogs.tedneward.com/post/the-vietnam-of-computer-science/). Particularly, these difficulties are referred to as the [object-relational impedance mismatch](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch).
* Database testing, still stays on principles and guidelines. No widely practical use yet. Refactoring an enterprise
application is error prone due to lack of database testing.
* Separation of the graphical user interface from the business logic or back-end logic (the data model), is still a challenge task. Frameworks such as [MVVM](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel) exists, but it's far from ideal: it will hit the wall when dealing with complex layout or complex interactivity; refactoring UI logic is still error prone, etc.

The above challenges impose great burdens for developing and further changing an enterprise application. Many frameworks are trying to solve these problems however they are all far from ideal. RDO.Net is the only solution to these problems in an integral, not an after-thought way (strongly recommended reading through):

* [Enterprise Application, the Right Way](xref:enterprise_application_the_right_way)
* [ORM/Data Access, the Right Way](xref:orm_data_access_the_right_way)
* [Data Presentation, the Right Way](xref:data_presentation_the_right_way)

In the end, your application follows your business in a no-more-no-less basis - it adapts to your business, not vice versa:

* Your application is 100% strongly typed from database to GUI, with extremely clean code in C#/VB.Net. No fancy HQL, XAML or any other DSL - traditional problems are solved in a traditional way.
* Your data access is unbeatable for both performance and maintainability because you're writing native SQL using C#/VB.Net.
* A revolutionary one-for-all, fully customizable data presenter is provided to handle view states including layout, data binding and data validation, all in clean C#/VB.Net code. Most complex controls such as ListBox, TreeView, DataGrid are eliminated. You have the greatest control over your UI because you're dealing with basic control such as label and text box directly.
* JSON serialization/deserialization is a first class citizen - unbeatable performance because no reflection required.
* Database testing and deployment is a first class citizen. You can easily mock part of database with testing data, generate database from clean C#/VB.Net code, or generate C#/VB.Net code from table data in database, right in Visual Studio.
* And much more with a extremely lightweight runtime - you only need to add several dlls into your application, only hundreds or even tens of KBs in size!

## A Taste of RDO.Net

### The Model

[!code-csharp[SalesOrderDetail](../../../samples/AdventureWorksLT.Data.SqlServer.CSharp/AdventureWorksLT.Data/SalesOrderDetail.cs)]

The code of model can be manipulated in Model Visualizer tool window in Visual Studio:

![image](/images/SalesOrderDetailModelVisualizer.jpg)

### The Database

[!code-csharp[Db](../../../samples/AdventureWorksLT.Data.SqlServer.CSharp/AdventureWorksLT.Data/Db.cs)]

The code of database can be manipulated via Db Visualizer tool window in Visual Studio:

![image](/images/AdventureWorksLTDbVisualizer.jpg)

### Data Access (CRUD)

[!code-csharp[Db](../../../samples/AdventureWorksLT.Data.SqlServer.CSharp/AdventureWorksLT.Data/Db.Api.cs#SalesOrderCRUD)]

### Data Presentation

[!code-csharp[Db](../../../samples/AdventureWorksLT.WpfApp/SalesOrderWindow.DetailPresenter.cs)]

This will produce the following data grid UI, with foreign key lookup and paste append from clipboard:

![image](/images/SalesOrderDetailUI.jpg)

### Mock Database for Testing

```csharp
public sealed class MockSalesOrder : DbMock<Db>
{
    public static Task<Db> CreateAsync(Db db, IProgress<DbInitProgress> progress = null, CancellationToken ct = default(CancellationToken))
    {
        return new MockSalesOrder().MockAsync(db, progress, ct);
    }

    // This method is generated by a tool
    private static DataSet<SalesOrderHeader> Headers()
    {
        DataSet<SalesOrderHeader> result = DataSet<SalesOrderHeader>.Create().AddRows(4);
        SalesOrderHeader _ = result._;
        _.SuspendIdentity();
        _.SalesOrderID[0] = 1;
        _.SalesOrderID[1] = 2;
        ...
        _.ResumeIdentity();
        return result;
    }

    // This method is generated by a tool
    private static DataSet<SalesOrderDetail> Details()
    {
        DataSet<SalesOrderDetail> result = DataSet<SalesOrderDetail>.Create().AddRows(32);
        SalesOrderDetail _ = result._;
        _.SuspendIdentity();
        ...
        _.SalesOrderDetailID[0] = 1;
        _.SalesOrderDetailID[1] = 2;
        ...
        _.ResumeIdentity();
        return result;
    }

    protected override void Initialize()
    {
        // The order of mocking table does not matter, the dependencies will be sorted out automatically.
        Mock(Db.SalesOrderDetail, Details);
        Mock(Db.SalesOrderHeader, Headers);
    }
}
```

The code for testing data is generated from database:

![image](/images/SalesOrderDetailMockDb.jpg)
